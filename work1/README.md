# 学习笔记

1. 数据结构 List 与 Dict 的使用

   经过学习，发现 List 的功能及其强大，包括但不限于嵌套，任意位置增添，任意合并与拆分，并提供了优秀的搜索方式，具体函数不在此列举，但有一点
   可以明确 List 的功能对比 C++ 完全可以说的上随心所欲，但是复杂度无法保证。换言之，List 拥有 C++ 中数组的所有功能，并且插入和查询全部都进行了集成
   ~~（懒人必备）。~~
   对于 DIct 来说，经过学习后我发现这其实是一个大号的 map，但比起 C++ 中的 stl 库，Dict显然又提供了更多的功能，包括但不限于 Dict 合并，并且比起 map 的不可视，Dict 拥有优秀的遍历方法，不再需要 map 那样的指针遍历，并且  dict.keys()  函数的存在大大增加了 Dict 可调试性。
2. Lamba函数的使用

   经过学习，发现 Lamba 函数是为了减少代码量以及形式化调用各种函数，且考虑到 python 各种代码有各种各样的返回值，所以可以与各种函数进行嵌套。
   但是最大的作用貌似只是减少代码量，更多功能等待学习。
3. 装饰器

   经过学习，发现装饰器功能其实是为了便于调试而存在的功能，因为单论功能实现其实完全可以嵌套函数，但是装饰器的存在使可能要更改函数的情况变得不需
   要更改 function，任何的调试实现只需要调用装饰器即可。而对于类装饰器，貌似有更多的功能比如限制变量单一，但是类的知识我尚未完整学习，所以待定。
4. 类和魔术方法

   类是许多语言最基础的封装方式，虽然 python 不像C#那样专门面向对象编程，但 class 确实为 python 提供了封装的能力，而在 class 中，python提供了许多像php中的那些魔术方法，这为封装提供了更为优秀的可操控能力，相对于C++来说又减少了码量和该死的指针。
5. 正则表达式

   在 python 中，python提供了一个re库用来实现正则表达式的使用,并且提供了方便的sub方法进行字符替换，但我并没有找到可以返回所有匹配项的便捷方法，所以可能还要老老实实的写AC自动机（。
   关于正则表达式本身，其实就是定义的一堆规则使得可以筛选字符串，但是真的有太多太多的特殊值要记，所以很难受。
6. 列表推导式

   感觉跟Lamba函数没有什么区别，只是列表推导式强调了生成队列，并且有字典推导式和元组推导式等等衍生，但底层感觉都可以用Lamba实现，所以不过多赘述。
7. generator生成器（yield关键字）

   这个是一个很nb的东西所以详细一点。这块知识点最重要的其实就是yield这个关键字，这个关键可以让我们实现在函数运行一半的时候在不return的情况下返回参数的功能，搭配next()函数便可以调用，并且这个功能的底层逻辑实现是跑到yield后暂停，然后再接着跑，这不仅减少了空间占用也减少更多无意义的运算。
   说到generator，其实就是利用yield来进行动态生成，并且yield推导式只和列表推导式差了一个括号，非常的好写。
   yield甚至可以嵌套，使用yield from即可，并且这么调用会自动返回委托的所有yield（节省循环）。
8. OOP面向对象编程思想

   说实话我觉得在学习过C#和Unity之后这个思想非常的好理解，就拿游戏举个例子，我们操控的是主角，那么我们的主角就要有各种可以操控的行为，所以我们定义一个类，这个类储存了所有主角所需要的代码，我们还可以细分，比如我们的主角有动作模组，外貌变化模组等等，当我们写完之后，把这一个类封装到主角这个object上，那么我们的角色就拥有了可操控行为，这就是封装。
   至于继承，我们的角色升级之后会获得新的技能，而我们也要保留原来的功能，所以我们在原来的基础上添加模块即可，这就是继承。
   至于多态性，假设我们已经封装了一个行走功能，但是一个角色只会跑，一个角色只会走，那么我们便要为两个角色在行走的功能基础上实现不同的速度和姿势，这就是多态。
9. Type Hint类型注释

   这个感觉没啥东西，因为我是C++转过来的，对于python这个弱类型语言来说，变量的定义并不需要声明数据类型，并且python在运行的时候会进行各种各样的强制转换，比如说有的时候你明明希望这个变量是一个int，但是python给你处理为了字符串，或者你知道别人不知道，所以这就导致可能出现一天都找不到的那种问题，所以我们需要类型注释，告诉别人也是告诉自己这个变量的类型应该是什么。
   我们也可以下载mypy库来检验变量是否为我们所标注的类型


# 生成式AI导论学习笔记


学习过生成式AI导论后，其实对于AI的底层逻辑仍是一知半解，但毕竟是导论，也只能学到大体知识，具体实现仍需要后续学习。

1.何为大语言模型

令我比较惊讶的一点是，现在的大语言模型仍然没有跳脱出算法的范畴，我曾听人说大语言模型模拟了人类的思考，我花费过很多的时间去思考AI该如何模拟人的思维，但现在看来AI并没有模仿人的思维，正如算法题一样，注重的从来都是结果而不是过程，大语言模型是通过无数实例的训练后在文字接龙游戏中采取最优解，所以这仍然是基于基础算法开发而来。

2.如何进行结果优化

大语言模型是进行文字接龙，这显然就会衍生出一个问题便是如何使AI的输出变得更让人可以接受，我们知道对于文字接龙来说它的可能性实在是太多了，所以要进行调整参数，还有迭代生成等等方法，我不在此列举。

3.杂谈

大语言模型的训练过程其实是难以观测的，所以用户的输入可以引导大语言模型的生成方式。此外，为了使大语言模型拥有更多的功能和更为准确的输出，开发者们令大语言模型可以调用各种工具以及自行编写代码并执行，但是导论中并没有解释大语言模型究竟是怎么判断调用情况以及如何编写代码，所以我也不知。
